---
title: Verify Your Contracts On Etherscan 100% Of The Time
date: 2020-10-17
author: Kendrick Tan
categories: ["ethereum", "tooling"]
---

---

### Update #1

`solc-sjw` has been renamed to [solt](https://github.com/hjubb/solt). Read the [accompanying blogpost](https://blog.jubb.xyz/post/solt-release/).

---

It is a well known fact that the **hardest** part of being a solidity developer is verifying your deployed contracts on [etherscan](https://etherscan.io). (See [here](https://github.com/gnosis/verify-on-etherscan/issues/5), [here](https://github.com/UMAprotocol/protocol/issues/1807), [here](https://github.com/rkalis/truffle-plugin-verify/issues/39), and [here](https://ethereum.stackexchange.com/questions/19437/etherscan-how-can-i-verify-a-contract-with-multiple-imports-deployed-with-truff))

As a defi veteran (8 months and counting), I've had countless nightmarish encounters with [verifying contracts on etherscan](https://github.com/kendricktan/etherscan-verification-horrors). Now that I've emerged victorious from the battle field, I would like to share my experiences, and a new tool made by my good friend [hjubb](https://github.com/hjubb/) on verifying your contracts on etherscan, **100% of the time**, 99.99% of the time.

### Why Does it Fail?

One of the most common verification methods is to [flatten your contracts](https://twitter.com/ethchris/status/1296121526601875456) **after compilation and deployment** and verify the flatten contracts.

This works on simple contracts, but on more complicated contracts where `pragma experimental ABIEncoderV2` is being used, the **location and presence of that declaration** changes the output bytecode significantly. This is demonstrated [here](https://github.com/kendricktan/etherscan-verification-horrors).

More concretely, if:

1. You have 2 files: `A.sol`, and `B.sol`
2. If `A.sol` contains `ABIEncoderV2` and was compiled with standard frameworks, `B.sol`'s generated bytecode will be compiled without `ABIEncoderV2`.
3. However, if `A.sol` and `B.sol` were to be flatten, `ABIEncoderV2` will be present in both files, resulting in a different bytecode.

There are also other suspects, such as [truffle](https://trufflesuite.com) compiling contracts with absolute filepaths, resulting in a different swarmhash when compiled on a different machine (etherscan has however stated that it [shouldn't affect anything](https://github.com/trufflesuite/truffle/issues/456#issuecomment-370133955)).

### Standard JSON

Fortunately, there is another format the etherscan verification process supports -- the [standard json](https://solidity.readthedocs.io/en/v0.6.12/using-the-compiler.html#compiler-input-and-output-json-description) format.

It looks something like:

```json
{
  "language": "Solidity",
  "sources": {
    "contracts/ContractA.sol": {
      "content": "<SOURCE_CODE A>"
    },
    "contracts/ContractB.sol": {
      "content": "<SOURCE_CODE B>"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    }
  }
}
```

This input format allows us to **verify contracts that spans across multiple files** without needing to flatten them.

### Enter -- ~~solc-sjw~~ solt

~~`solc-sjw` stands for solc-**s**tandard-**j**son-**w**riter. It is a **static binary** written in Kotlin-Native (tm) that helps you format your solidity contracts into the standard input format. Its written by my good friend [hjubb](https://twitter.com/harris_s0n), and you can find the [source code here](https://github.com/hjubb/solc-sjw).~~

`solc-sjw` has been renamed to [solt](https://github.com/hjubb/solt). Read the [updated blogpost](https://blog.jubb.xyz/post/solt-release/) for more information


#### Usage Example

In this example, we'll walk through an example on how to generate a standard input json format, and verify it on etherscan.

1. Generate your standard-input json. We'll be using [yearn's protocol](https://github.com/iearn-finance/yearn-protocol.git) in this example.

```bash
git clone https://github.com/iearn-finance/yearn-protocol.git
cd yearn-protocol
solt write contracts

# A new file called solc-input-contracts.json should be present in the current working directory
```

2. Go to deployed contract's location on etherscan and select `Solidity: Standard-Json-Input` as the verification method.

![](https://i.imgur.com/uHqWUw0.png)


3. Follow the process and upload the generated `solc-input.json` click, click, click...

And it should be verified now.

### Conclusion

Tl;dr: [standard json](https://solidity.readthedocs.io/en/v0.6.12/using-the-compiler.html#compiler-input-and-output-json-description) good.

Have fun verifying!